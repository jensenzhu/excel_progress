## 📊 关于"自然语言交互复杂度"的解释
这个指的是系统能够理解和执行的自然语言指令的复杂程度：

### 简单交互（Level 1）
```
"计算A列的平均值"
"筛选B列大于100的行"
"选择第3列到第5列"
```
→ 单一操作，针对单个数据表

### 中等复杂（Level 2）
```
"筛选销售额大于1000的行，然后计算这些行的平均利润"
"将A列和B列相加，结果存为新列C"
"按地区分组，计算每个地区的总销售额"
```
→ 多步骤操作，但仍在单表内

### 复杂交互（Level 3）← 你的需求
```
"从表1提取A列数据，计算平均值后填入表2的B5单元格"
"将表1的姓名列和表2的年龄列合并，存为新表"
"用表1的销售额更新表2中对应产品的库存"
```
→ 跨表操作，涉及数据提取、计算、插入等复杂流程

## 🎯 重新设计的系统架构
### 核心功能模块 1. 多表管理器
```
功能：
- 同时加载多个Excel文件
- 管理多个DataFrame
- 表格切换和对比视图
- 表间关系映射（如通过共同列连接）
``` 2. 增强的自然语言解析器
```
功能：
- 识别表引用（"表1"、"源表"、"目标表"）
- 识别单元格引用（"B5"、"第3行第2列"）
- 识别操作流向（提取→计算→插入）
- 支持链式操作（"从...提取...然后...最后..."）
``` 3. 数据操作引擎
```
功能：
- 单表操作（筛选、计算、排序）
- 跨表操作（合并、连接、数据迁移）
- 单元格级操作（读取、写入特定单元格）
- 数据映射（基于键值匹配）
``` 4. 可视化界面
```
功能：
- 多表标签页视图
- 并排对比模式
- 数据流向可视化
- 操作预览（执行前显示将要做什么）
```
## 💡 典型使用场景
### 场景1：数据迁移
```
用户: "打开sales.xlsx和report.xlsx"
系统: [显示两个标签页]

用户: "从sales表提取产品名称列，计算每个产品的总销量，
     然后将结果填入report表的C2到C100区域"
系统: [显示操作预览]
     - 提取：sales['产品名称']
     - 计算：按产品分组求和
     - 插入：report['C2:C100']

用户: "确认执行"
系统: [执行并显示结果]
```
### 场景2：数据更新
```
用户: "用inventory表的库存数量更新sales表的对应产品库存"
系统: [识别共同列：产品ID]
     [显示将要更新的行数]
     [执行更新]
```
### 场景3：数据合并
```
用户: "将表A的姓名列和表B的工资列合并，
     根据员工ID匹配，保存为新表merged.xlsx"
系统: [执行合并操作]
```
### 场景4：单元格级操作
```
用户: "计算表1所有行的总和，结果存入表2的A1单元格"
系统: [执行计算并写入]
```
## 🏗️ 技术架构（Streamlit方案）
### 项目结构
```
excelprogress/
├── app.py                      # Streamlit主应用
├── core/
│   ├── data_manager.py         # 多表数据管理
│   ├── nlp_parser.py           # 自然语言解析
│   ├── operation_engine.py     # 操作执行引擎
│   └── cell_operations.py      # 单元格级操作
├── ui/
│   ├── table_viewer.py         # 表格展示组件
│   ├── chat_interface.py       # 聊天界面
│   └── operation_preview.py    # 操作预览
├── utils/
│   ├── excel_handler.py        # Excel读写
│   └── validators.py           # 数据验证
├── config/
│   ├── prompts.py              # LLM提示词
│   └── settings.py             # 配置参数
├── requirements.txt
└── README.md
```
### 核心代码架构 1. 数据管理器
```
class DataManager:
    def __init__(self):
        self.tables = {}  # {table_name: DataFrame}
        self.active_table = None
    
    def load_table(self, file_path, table_name):
        self.tables[table_name] = pd.read_excel(file_path)
    
    def get_table(self, table_name):
        return self.tables[table_name]
    
    def get_cell_value(self, table_name, cell_ref):
        # 解析"A5" → (row=4, col=0)
        pass
    
    def set_cell_value(self, table_name, cell_ref, value):
        pass
``` 2. 自然语言解析器
```
class NLPParser:
    def __init__(self, llm_client):
        self.llm = llm_client
    
    def parse_instruction(self, instruction, context):
        """
        解析自然语言指令，返回结构化操作
        """
        prompt = f"""
        当前已加载的表：{list(context.tables.keys())}
        当前激活表：{context.active_table}
        
        用户指令：{instruction}
        
        请解析为结构化操作JSON格式：
        {{
            "operations": [
                {{
                    "type": "extract|calculate|insert|merge",
                    "source_table": "...",
                    "target_table": "...",
                    "columns": [...],
                    "rows": "...",
                    "cells": "...",
                    "calculation": "...",
                    "condition": "..."
                }}
            ]
        }}
        """
        return self.llm.generate(prompt)
``` 3. 操作引擎
```
class OperationEngine:
    def __init__(self, data_manager):
        self.dm = data_manager
    
    def execute_operations(self, operations):
        results = []
        for op in operations:
            if op['type'] == 'extract':
                result = self._extract(op)
            elif op['type'] == 'calculate':
                result = self._calculate(op)
            elif op['type'] == 'insert':
                result = self._insert(op)
            elif op['type'] == 'merge':
                result = self._merge(op)
            results.append(result)
        return results
    
    def _extract(self, op):
        df = self.dm.get_table(op['source_table'])
        return df[op['columns']]
    
    def _insert(self, op):
        df = self.dm.get_table(op['target_table'])
        # 支持单元格级插入
        if 'cell' in op:
            row, col = self._parse_cell_ref(op['cell'])
            df.iloc[row, col] = op['value']
        # 支持范围插入
        elif 'range' in op:
            # 插入数据到指定范围
            pass
``` 4. Streamlit UI
```
import streamlit as st

def main():
    st.title("Excel智能数据操作助手")
    
    # 侧边栏：文件管理
    with st.sidebar:
        st.header("📁 文件管理")
        uploaded_files = st.file_uploader(
            "上传Excel文件",
            accept_multiple_files=True,
            type=['xlsx', 'xls']
        )
        
        # 表格切换
        if st.session_state.get('tables'):
            active_table = st.selectbox(
                "选择活动表格",
                list(st.session_state['tables'].keys())
            )
    
    # 主区域：表格展示
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.header("📊 数据预览")
        if active_table:
            display_table(st.session_state['tables'][active_table])
    
    with col2:
        st.header("💬 自然语言操作")
        user_input = st.text_area(
            "输入操作指令",
            placeholder="例如：从表1提取A列，计算平均值后填入表2的B5单元格"
        )
        
        if st.button("执行"):
            # 解析并执行操作
            operations = parse_natural_language(user_input)
            results = execute_operations(operations)
            display_results(results)
```
## 🎨 UI设计
### 布局方案
```
┌─────────────────────────────────────────────────────────┐
│  Excel智能数据操作助手                    [上传文件]    │
├─────────────────────────────────────────────────────────┤
│  侧边栏          │  主区域                              │
│  ┌────────────┐  │  ┌────────────────────────────────┐ │
│  │ 已加载表格 │  │  │ 表1 (sales.xlsx)  [x]          │ │
│  │ □ 表1     │  │  │ ┌────────────────────────────┐ │ │
│  │ ☑ 表2     │  │  │ │ A      B      C      D    │ │ │
│  │ □ 表3     │  │  │ ├────────────────────────────┤ │ │
│  │            │  │  │ │ 产品   销售额  利润   ... │ │ │
│  │ 操作历史  │  │  │ │ A      1000   200    ... │ │ │
│  │ 1. 提取A列│  │  │ │ B      1500   300    ... │ │ │
│  │ 2. 计算总和│  │  │ │ ...                      │ │ │
│  │ 3. 插入B5 │  │  │ └────────────────────────────┘ │ │
│  └────────────┘  │  │                                  │ │
│                  │  │ [表2 (report.xlsx)  [x]]        │ │
│                  │  │ ┌────────────────────────────┐ │ │
│                  │  │ │ ...                          │ │ │
│                  │  │ └────────────────────────────┘ │ │
│                  │  └────────────────────────────────┘ │
│                  │                                      │
│                  │  ┌────────────────────────────────┐ │
│                  │  │ 💬 自然语言操作                 │ │
│                  │  │ ┌────────────────────────────┐ │ │
│                  │  │ │ 输入指令...                 │ │ │
│                  │  │ │ [执行] [预览]               │ │ │
│                  │  │ └────────────────────────────┘ │ │
│                  │  │                                │ │
│                  │  │ 📋 操作预览                    │ │
│                  │  │ • 从表1提取A列                 │ │
│                  │  │ • 计算平均值                   │ │
│                  │  │ • 插入到表2的B5单元格          │ │
│                  │  │                                │ │
│                  │  │ [确认执行] [取消]              │ │
│                  │  └────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```
## 🔧 关键技术实现
### 1. 单元格引用解析
```
def parse_cell_reference(cell_ref):
    """
    将"A5"转换为(row=4, col=0)
    """
    import re
    match = re.match(r'([A-Z]+)(\d+)', cell_ref)
    if match:
        col_str, row_str = match.groups()
        col = sum((ord(c) - ord('A') + 1) * (26 ** i) 
                  for i, c in enumerate(reversed(col_str))) - 1
        row = int(row_str) - 1
        return row, col
    return None
```
### 2. 数据范围解析
```
def parse_range(range_ref):
    """
    将"A5:C10"转换为(start_row, start_col, end_row, end_col)
    """
    if ':' in range_ref:
        start, end = range_ref.split(':')
        start_row, start_col = parse_cell_reference(start)
        end_row, end_col = parse_cell_reference(end)
        return (start_row, start_col, end_row, end_col)
    return None
```
### 3. 跨表数据映射
```
def map_data_between_tables(source_df, target_df, key_column):
    """
    基于键列在两个表之间映射数据
    """
    merged = pd.merge(
        source_df, 
        target_df, 
        on=key_column, 
        how='left'
    )
    return merged
```
## 📋 实现计划
### 阶段1：基础功能
- Streamlit应用框架搭建
- 单表加载和展示
- 基础自然语言解析（单表操作）
### 阶段2：多表支持
- 多表管理器
- 表格切换UI
- 跨表操作解析
### 阶段3：高级功能
- 单元格级操作
- 数据范围操作
- 操作预览和确认
### 阶段4：优化增强
- 操作历史和撤销
- 批量操作
- 数据验证和错误处理